{"id":1068117873,"lang":"typescript","lang_name":"TypeScript","time":"2 weeks, 3 days","timestamp":1696543304,"status":10,"status_display":"Accepted","runtime":"92 ms","url":"/submissions/detail/1068117873/","is_pending":"Not Pending","title":"Merge k Sorted Lists","memory":"48.6 MB","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction heap(data, comparator /*f: (a,b) => Boolean */)\n{\n\tthis.comparator = comparator;\n\tthis.data = data;\n\tthis.heapify = function(i){\n\t\tvar left = 2*i;\n\t\tvar right =2*i+1;\n\t\tvar minmax=i;\n\t\tif(left-1 < this.data.length) {\n\t\t\tif(this.comparator(this.data[left-1],this.data[minmax-1]))\n\t\t\t{\n\t\t\t\tminmax = left;\n\t\t\t}\n\t\t}\n\t\tif(right-1 < this.data.length) {\n\t\t\tif(this.comparator(this.data[right-1],this.data[minmax-1]))\n\t\t\t{\n\t\t\t\tminmax = right;\n\t\t\t}\n\t\t}\n\t\tif(minmax != i)\n\t\t{\n\t\t\tvar temp = this.data[i-1];\n\t\t\tthis.data[i-1] = this.data[minmax-1];\n\t\t\tthis.data[minmax-1] = temp;\n\t\t\tthis.heapify(minmax);\n\t\t}\n\t};\n\t\n\tthis.heapifyGeneric = function(i,width) {\n\t\tvar child_indices = [];\n\t\tvar minmax = i;\n\t\tfor(var j=0; j < width; j++)\n\t\t{\n\t\t\tchild_indices[j] = i*width+j;\n\t\t}\n\t\t\n\t\tfor(var j=0; j < width; j++)\n\t\t{\n\t\t\tif(child_indices[j] < this.data.length)\n\t\t\t{\n\t\t\t\tif(this.comparator(this.data[child_indices[j]-1],this.data[i-1]))\n\t\t\t\t{\n\t\t\t\t\tminmax = child_indices;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minmax != i)\n\t\t{\n\t\t\tvar temp = this.data[i-1];\n\t\t\tthis.data[i-1] = this.data[minmax-1];\n\t\t\tthis.data[minmax-1] = temp;\n\t\t\tthis.heapify(minmax,width);\n\t\t}\n\t}\n\t\n\tthis.buildHeap = function() {\n\t\tfor(var i=Math.floor(this.data.length/2); i >0 ; i--)\n\t\t{\n\t\t\tthis.heapify(i);\n\t\t}\n\t\n\t}\n\t\n\tthis.buildHeapGeneric = function(width) {\n\t\tfor(var i=Math.floor(this.data.length/width); i >0 ; i--)\n\t\t{\n\t\t\tthis.heapifyGeneric(i,width);\n\t\t}\n\t}\n\tthis.buildHeap();\n\t\n\tthis.toString = function() {\n\t\tvar output = \"[\";\n\t\tfor(var i=0; i < this.data.length; i++)\n\t\t{\n\t\t\toutput += this.data[i].ts+\",\";\n\t\t}\n\t\toutput+=\"]\";\n\t\treturn output;\n\t}\n\t\n\tthis.empty = function() {\n\t\treturn this.data.length >0;\n\t}\n\t\n\tthis.extractTop = function() {\n\t\tif(this.data.length <1)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tvar top = this.data[0];\n\t\tthis.data[0] = this.data[this.data.length-1];\n\t\tthis.data.length -=1;\n\t\tthis.heapify(1);\n\t\treturn top;\n\t}\n\t\n\tthis.insert = function(x) {\n\t\tthis.data.length +=1;\n\t\tthis.data[this.data.length-1] = x;\n\t\tvar i = this.data.length;\n\t\twhile(i > 1 && this.comparator(this.data[i-1],this.data[this.parent(i)-1]))\n\t\t{\n\t\t\tvar temp = this.data[this.parent(i)-1];\n\t\t\tthis.data[this.parent(i)-1] = this.data[i-1];\n\t\t\tthis.data[i-1] = temp;\n\t\t\ti = this.parent(i);\n\t\t}\n\t}\n\t\n\tthis.parent = function(i) {\n\t\treturn Math.floor(i/2);\n\t}\n\t\n\tthis.alterKey = function(value,key) {\n\t\tfor(var j = 0; j < this.data.length; j++) {\n\t\t\tif(this.data[j].key === key) {\n\t\t\t\tvar i = j+1;\n\t\t\t\tthis.data[j].ts = value;\t\n\t\t\t\t/*while(i > 1 && this.comparator(this.data[i-1],this.data[this.parent(i)-1]))\n\t\t\t\t{\n\t\t\t\tvar temp = this.data[this.parent(i)-1];\n\t\t\t\tthis.data[this.parent(i)-1] = this.data[i-1];\n\t\t\t\tthis.data[i-1] = temp;\n\t\t\t\ti = this.parent(i);\n\t\t\t\t}\n\t\t\t\tthis.heapify(i);*/\n\t\t\t\tthis.buildHeap();\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nvar mintimecomparator = function(a,b) {\n\treturn a.ts < b.ts; //min heap\n}\n\nfunction mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n    let heaplist = lists.filter(x => x != null);\n    \n    let result: ListNode | null = null;\n    let tail: ListNode | null = null;\n    let klistheap = new heap(heaplist, (a,b) => a.val < b.val);\n    let next: ListNode | null = null;\n    while((next = klistheap.extractTop(), next != null)) {\n        if(result == null) {\n            result = new ListNode(next.val);\n            if(next.next != null) {\n                klistheap.insert(next.next);\n            }\n            tail = result;\n        }else{\n            tail.next = new ListNode(next.val);\n            tail = tail.next;\n            if(next.next != null) {\n                klistheap.insert(next.next);\n            }\n        }\n    } \n    return result;\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-k-sorted-lists","has_notes":false,"flag_type":1}